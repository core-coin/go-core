package main // import "ekyu.moe/cryptonight/cmd/cnhash"

import (
	"bytes"
	"encoding/binary"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"runtime"
	"sync/atomic"
	"time"

	"ekyu.moe/cryptonight"
)

func main() {
	os.Exit(realMain())
}

func realMain() int {
	var (
		bench       bool
		inHex       bool
		outBinary   bool
		includeDiff bool
		inFile      string
		outFile     string
		variant     int

		in  io.Reader = os.Stdin
		out io.Writer = os.Stdout

		stderr = log.New(os.Stderr, "cnhash: ", 0)
	)

	flag.BoolVar(&bench, "bench", false, "Benchmark mode, don't do anything else.")
	flag.BoolVar(&includeDiff, "include-diff", false, "Append the difficulty of the result hash to the output. If -out-binary is not given, the difficulty will be appeneded to the output in decimal with comma separated (CSV friendly), otherwise it will be appeneded to the hash binary (which is 32 bytes long) directly, in 8 bytes little endian.")
	flag.BoolVar(&inHex, "in-hex", false, "Read input in hex instead of binary.")
	flag.BoolVar(&outBinary, "out-binary", false, "Produce output in binary (little endian) instead of hex.")
	flag.StringVar(&inFile, "in-file", "", "Read input from file instead of stdin.")
	flag.StringVar(&outFile, "out-file", "", "Produce output to file instead of stdout.")
	flag.IntVar(&variant, "variant", 0, "Set CryptoNight variant, default 0. This applies to benchmark mode as well.")
	flag.Parse()

	if bench {
		// picked from cryptonight_test.go, see comment there
		benchData := [4][]byte{
			{0xa8, 0xab, 0xb6, 0xb, 0x87, 0xa3, 0x49, 0x26, 0x72, 0xbf, 0x9d, 0x18, 0xd4, 0xd5, 0x2c, 0x4c, 0x7b, 0x3f, 0x5a, 0xdd, 0x25, 0xdd, 0x8c, 0xd5, 0xe5, 0xd7, 0x85, 0xcd, 0x30, 0xde, 0x5f, 0x10, 0xb7, 0x32, 0xce, 0x45, 0xb8, 0x74, 0x5d, 0xf5, 0x2a, 0x87, 0x93, 0xcb, 0x51, 0x2b, 0xf7, 0x77, 0xc2, 0xa7, 0xcc, 0xc0, 0xb4, 0x96, 0x3e, 0x43, 0x8f, 0x3f, 0xbf, 0x16, 0x78, 0xf7, 0xa8, 0xb4, 0x5d, 0xb, 0x4d, 0xdf, 0xc5, 0x10, 0xbe, 0xaa, 0xd1, 0xf3, 0xef, 0x29},
			{0xe, 0xa3, 0x74, 0x46, 0xbf, 0x65, 0x53, 0xb4, 0xab, 0xc0, 0x11, 0x3e, 0x2b, 0x5b, 0x9, 0x26, 0xb8, 0x59, 0xf6, 0xb9, 0xbf, 0x5a, 0xb, 0x43, 0x95, 0x45, 0x8a, 0xa, 0x5f, 0xed, 0xb9, 0x9c, 0x79, 0xce, 0x6c, 0xbc, 0x7f, 0xa, 0x4a, 0xe3, 0x6f, 0x67, 0xb9, 0x89, 0xe6, 0x4, 0x2f, 0xe9, 0xe0, 0xd6, 0x8a, 0x50, 0x9f, 0x44, 0x7d, 0x96, 0x3f, 0xee, 0xc2, 0x71, 0x27, 0xfc, 0xf1, 0x43, 0xcd, 0xe8, 0x36, 0x34, 0x29, 0x8e, 0xd, 0xe9, 0x89, 0xb4, 0xae, 0xfd},
			{0xc5, 0xf0, 0x6f, 0xd5, 0x8, 0xe, 0x1d, 0x60, 0xb2, 0x6b, 0xe0, 0xd7, 0x7e, 0xa, 0x56, 0xef, 0x6c, 0xfb, 0x3b, 0xc7, 0x2d, 0xc5, 0x7b, 0x8, 0xb6, 0x54, 0x1, 0x65, 0xe1, 0x20, 0x22, 0xf2, 0x26, 0x5e, 0x4b, 0xe2, 0x49, 0x6c, 0x10, 0x1b, 0x8c, 0x43, 0xcb, 0xd5, 0xbd, 0x1e, 0x7c, 0x61, 0xd8, 0x6e, 0xe2, 0x47, 0x8c, 0x46, 0x44, 0xc3, 0x1a, 0x5, 0xb7, 0x5f, 0x85, 0x8b, 0x2a, 0x68, 0x55, 0xb0, 0x5f, 0xe4, 0xc8, 0xc3, 0xac, 0x52, 0x1e, 0x3f, 0xe3, 0x18},
			{0xfc, 0x11, 0x56, 0x9f, 0xae, 0xe8, 0x99, 0xd3, 0x62, 0xb8, 0x1a, 0xf6, 0xd3, 0xdc, 0x29, 0x69, 0x34, 0xd3, 0x98, 0x3c, 0x7f, 0x27, 0x93, 0x3, 0x3f, 0xf4, 0x28, 0x42, 0xcb, 0xe9, 0x9d, 0x5e, 0xc6, 0xad, 0x89, 0x36, 0x61, 0x87, 0x72, 0x30, 0x3c, 0xd5, 0x57, 0x91, 0xc6, 0xca, 0x54, 0x7a, 0xa9, 0xe3, 0x5e, 0x83, 0xd0, 0x8a, 0x58, 0xa1, 0x90, 0xe5, 0x5d, 0x7e, 0x3f, 0x31, 0xc3, 0xd8, 0xad, 0x12, 0x3, 0xdd, 0xd6, 0x36, 0xf1, 0x52, 0x5d, 0x5d, 0x4a, 0x36},
		}

		hashes := uint64(0)
		lastSnap := hashes
		t := runtime.GOMAXPROCS(0)
		fmt.Println("GOMAXPROCS =", t)
		fmt.Println("variant =", variant)
		fmt.Println()
		fmt.Println("last 5 seconds (overall)")
		fmt.Println("------------------------")

		for i := 0; i < t; i++ {
			go func() {
				for j := 0; true; j++ {
					cryptonight.Sum(benchData[j&0x03], variant)
					atomic.AddUint64(&hashes, 1)
				}
			}()
		}

		i := uint64(0)
		for range time.Tick(5 * time.Second) {
			i++
			snap := atomic.LoadUint64(&hashes)
			fmt.Printf("%.2f H/s  (%.2f H/s)\n", float64(snap-lastSnap)/5, float64(snap)/float64(5*i))
			lastSnap = snap
		}

		return 0
	}

	if inFile != "" {
		f, err := os.Open(inFile)
		if err != nil {
			stderr.Println("open input file:", err)
			return 1
		}
		defer f.Close()
		in = f
	}
	if outFile != "" {
		f, err := os.Create(outFile)
		if err != nil {
			stderr.Println("create output file:", err)
			return 1
		}
		defer f.Close()
		out = f
	}

	blob, err := ioutil.ReadAll(in)
	if err != nil {
		stderr.Println("read input:", err)
		return 1
	}
	if inHex {
		blob = bytes.TrimSpace(blob)
		h := make([]byte, hex.DecodedLen(len(blob)))
		if _, err := hex.Decode(h, blob); err != nil {
			stderr.Println("decode hex:", err)
			return 1
		}
		blob = h
	}

	if variant == 1 && len(blob) < 43 {
		stderr.Println("variant 1 requires at least 43 bytes of input.")
		return 1
	}

	sum := cryptonight.Sum(blob, variant)
	diff := uint64(0)
	if includeDiff {
		diff = cryptonight.Difficulty(sum)
	}

	if outBinary {
		if _, err := out.Write(sum); err != nil {
			stderr.Println("write output:", err)
			return 1
		}

		if includeDiff {
			buf := make([]byte, 8)
			binary.LittleEndian.PutUint64(buf, diff)
			_, err = out.Write(buf)
		}
	} else {
		if includeDiff {
			_, err = fmt.Fprintf(out, "%x,%v\n", sum, diff)
		} else {
			_, err = fmt.Fprintf(out, "%x\n", sum)
		}
	}

	if err != nil {
		stderr.Println("write output:", err)
		return 1
	}

	return 0
}
